<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebXR Musik Visualisering</title>
  <meta name='viewport' content='width=device-width, initial-scale=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 1;
    }
    #start-button {
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <button id="start-button">Start AR</button>
  </div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let circles = [];
    let particles;
    let grid;
    let analyser;
    let dataArray;
    let clock = new THREE.Clock();
    let flashIntensity = 0;

    // Variabler til nye effekter
    let shootingStars = [];
    let shootingStarTimer = 0;
    let fireworks = [];
    let lavaLamps = [];
    let aurora;
    let auroraTimer = 0;
    let auroraVisible = false;
    let lastPeakTime = 0;

    init();

    function init() {
      // Scene og kamera
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0); // Sæt baggrunden til transparent
      document.body.appendChild(renderer.domElement);

      // Lys
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      // Event listener for "Start AR"-knappen
      document.getElementById('start-button').addEventListener('click', () => {
        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            if (supported) {
              const sessionInit = { optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body } };
              navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
            } else {
              alert('WebXR AR-session understøttes ikke på denne enhed.');
            }
          });
        } else {
          alert('WebXR ikke understøttet i denne browser.');
        }
      });
    }

    function onSessionStarted(session) {
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      document.getElementById('start-button').style.display = 'none';

      // Start animationssløjfen efter XR-sessionen er startet
      renderer.setAnimationLoop(render);

      // Opsæt lydanalyse
      navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then((stream) => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        source.connect(analyser);
      });

      // Opret og placer objekter direkte foran brugeren
      createObjects();
    }

    function createObjects() {
      // Placeringsmatrix for objekterne
      const position = new THREE.Vector3(0, 0, -2); // 2 meter foran brugeren
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3(1, 1, 1);
      const matrix = new THREE.Matrix4();
      matrix.compose(position, quaternion, scale);

      // Opret cirkler
      for (let i = 1; i <= 5; i++) {
        let geometry = new THREE.CircleGeometry(0.1 * i, 64);
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true });
        let circle = new THREE.Mesh(geometry, material);

        // Anvend matrixen for at placere cirklen
        circle.applyMatrix4(matrix);

        scene.add(circle);
        circles.push(circle);
      }

      // Opret partikelsky
      const particleCount = 1000;
      const particlesGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 4;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 4;

        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 1.0;
        colors[i * 3 + 2] = 1.0;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.03,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      particles = new THREE.Points(particlesGeometry, particlesMaterial);

      // Anvend matrixen for at placere partikelskyen
      particles.applyMatrix4(matrix);

      scene.add(particles);

      // Opret gitter
      const gridGeometry = new THREE.PlaneGeometry(6, 6, 20, 20);
      const gridMaterial = new THREE.MeshBasicMaterial({
        wireframe: true,
        transparent: true,
        opacity: 0.5,
        vertexColors: true,
        side: THREE.DoubleSide,
      });

      const gridColors = new Float32Array(gridGeometry.attributes.position.count * 3);
      for (let i = 0; i < gridColors.length; i += 3) {
        gridColors[i] = 0.0;     // Initial R værdi (mørkeblå)
        gridColors[i + 1] = 0.0; // Initial G værdi
        gridColors[i + 2] = 0.545; // Initial B værdi (#00008b)
      }
      gridGeometry.setAttribute('color', new THREE.BufferAttribute(gridColors, 3));

      grid = new THREE.Mesh(gridGeometry, gridMaterial);
      grid.position.set(0, 0, -3); // 3 meter foran brugeren

      // Rotér gitteret som ønsket
      grid.rotation.x = Math.PI / 4;  // 45 grader omkring X-aksen
      grid.rotation.z = Math.PI / 12; // 15 grader omkring Z-aksen

      // Skaler gitteret
      grid.scale.set(1.5, 1.5, 1.5); // Øg størrelsen til 150%

      scene.add(grid);
    }

    // Funktion til at skabe stjerneskud
    function createShootingStars(intensity) {
      const starCount = Math.floor(5 + intensity * 20); // Antal stjerner baseret på intensitet
      for (let i = 0; i < starCount; i++) {
        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0, 0, 0,
          0, 0.1, 0,
          0.5, 0, 0
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        const material = new THREE.MeshBasicMaterial({
          color: new THREE.Color(1, 1, 1),
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
        });
        const star = new THREE.Mesh(geometry, material);

        // Startposition bag kameraet
        star.position.set(
          (Math.random() - 0.5) * 4, // Tilfældig x-position
          (Math.random() - 0.5) * 4, // Tilfældig y-position
          5 + Math.random() * 5      // Baggrunden
        );

        // Bevægelsesdata
        const speed = 2 + intensity * 5;
        star.userData.velocity = new THREE.Vector3(
          0, // Ingen sidelæns bevægelse
          0, // Ingen lodret bevægelse
          -speed // Flyver fremad mod brugeren
        );

        scene.add(star);
        shootingStars.push(star);
      }
    }

    // Funktion til at skabe fyrværkerieksplosioner
    function createFirework() {
      const firework = {
        particles: [],
        life: 2, // Levetid i sekunder
      };
      const particleCount = 100;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = [];
      const colors = new Float32Array(particleCount * 3);
      const color = new THREE.Color(Math.random(), Math.random(), Math.random());

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;

        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        );
        velocities.push(velocity);

        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const particles = new THREE.Points(geometry, material);

      // Placering af fyrværkeri
      particles.position.set(
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 4,
        -2 - Math.random() * 3
      );

      scene.add(particles);
      firework.particles = particles;
      firework.velocities = velocities;
      fireworks.push(firework);
    }

    // Funktion til at skabe lava lampe effekt
    function createLavaLamp() {
      const geometry = new THREE.IcosahedronGeometry(0.5, 2);
      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(Math.random(), Math.random(), Math.random()),
        emissive: new THREE.Color(0.2, 0.2, 0.2),
        metalness: 0.5,
        roughness: 0.5,
        transparent: true,
        opacity: 0.8,
      });
      const lavaLamp = new THREE.Mesh(geometry, material);

      lavaLamp.position.set(
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 4,
        -2 - Math.random() * 3
      );

      scene.add(lavaLamp);
      lavaLamps.push(lavaLamp);
    }

    // Funktion til at skabe aurora borealis
    function createAurora() {
      const geometry = new THREE.PlaneGeometry(10, 5, 32, 32);
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          intensity: { value: 0 },
        },
        vertexShader: `
          varying vec2 vUv;
          varying float vWave;
          uniform float time;
          uniform float intensity;
          void main() {
            vUv = uv;
            vec3 pos = position;
            float wave = sin(pos.x * 2.0 + time) * 0.5 * intensity;
            pos.z += wave;
            vWave = wave;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          varying float vWave;
          void main() {
            gl_FragColor = vec4(0.5 + vWave, 0.8 + vWave, 1.0, 0.5);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });
      aurora = new THREE.Mesh(geometry, material);
      aurora.position.set(0, 5, -10);
      aurora.rotation.x = -Math.PI / 4;
      scene.add(aurora);
    }

    function render() {
      const delta = clock.getDelta();
      const elapsedTime = clock.elapsedTime;

      if (analyser) {
        analyser.getByteFrequencyData(dataArray);
        const avgFrequency = dataArray.reduce((a, b) => a + b) / dataArray.length;
        const intensity = avgFrequency / 255;

        // --- Slow-motion effekt ---
        const speedFactor = 0.5 + intensity;

        // Opdater cirkler
        circles.forEach((circle, index) => {
          const freqIndex = index % dataArray.length;
          const scale = 1 + dataArray[freqIndex] / 64; // Øg skaleringen
          circle.scale.set(scale, scale, scale);
          circle.material.opacity = Math.max(0.5, dataArray[freqIndex] / 255);
          circle.material.color.setHSL(dataArray[freqIndex] / 255, 1, 0.7); // Øg farvemætning
        });

        // Opdater partikler
        particles.rotation.y += 0.1 * delta * speedFactor;
        const colors = particles.geometry.attributes.color.array;
        for (let i = 0; i < colors.length / 3; i++) {
          const pulse = 0.5 + 0.5 * Math.sin(elapsedTime * 5 + i);
          colors[i * 3] = intensity * pulse; // Gør farver mere intense
          colors[i * 3 + 1] = (1 - intensity) * pulse;
          colors[i * 3 + 2] = 0.5 * pulse;
        }
        particles.geometry.attributes.color.needsUpdate = true;

        // Opdater gitterets bevægelse
        const positions = grid.geometry.attributes.position.array;
        const time = elapsedTime;
        const waveAmplitude = 1 + intensity; // Øget amplitude med intensitet
        const waveSpeed = 1.5 + intensity;  // Hurtigere bevægelse ved høj intensitet

        for (let i = 0; i < positions.length; i += 3) {
          const x = positions[i];
          const y = positions[i + 1];
          const frequency = dataArray[Math.floor((i / 3) % dataArray.length)];
          positions[i + 2] = waveAmplitude * Math.sin(x * 3 + time * waveSpeed) * (frequency / 128) +
                             waveAmplitude * Math.cos(y * 3 + time * waveSpeed) * (frequency / 128);
        }
        grid.geometry.attributes.position.needsUpdate = true;

        // Opdater gitterets farver
        const gridColors = grid.geometry.attributes.color.array;
        for (let i = 0; i < gridColors.length / 3; i++) {
          const frequency = dataArray[i % dataArray.length];
          gridColors[i * 3] = 0.1 + 0.8 * (frequency / 255);             // Rød komponent
          gridColors[i * 3 + 1] = 0.1 + 0.5 * ((255 - frequency) / 255); // Grøn komponent
          gridColors[i * 3 + 2] = 0.4 + 0.6 * (frequency / 255);         // Blå komponent
        }
        grid.geometry.attributes.color.needsUpdate = true;

        // --- Flash-effekt ved kraftige trommeslag ---
        if (avgFrequency > 200) {
          flashIntensity = 1;
          circles.forEach(circle => circle.material.color.setHSL(0.1, 1, 1)); // Lysere farver på cirkler
          particles.material.opacity = 1; // Gør partikler helt synlige

          // Opret fyrværkeri
          if (elapsedTime - lastPeakTime > 1) { // For at undgå for mange fyrværkerier
            createFirework();
            lastPeakTime = elapsedTime;
          }

          // Opret eksploderende partikler
          createExplodingParticles();
        }
        flashIntensity *= 0.9; // Fade effekten

        // Forstærk lysstyrken på cirkler og partikler
        circles.forEach(circle => {
          circle.material.opacity = Math.max(circle.material.opacity, 0.5); // Undgå nul opacitet
          circle.material.opacity += (1 - circle.material.opacity) * flashIntensity * delta;
          circle.material.opacity = Math.min(circle.material.opacity, 1);
        });
        particles.material.opacity = Math.max(particles.material.opacity, 0.5);
        particles.material.opacity += (1 - particles.material.opacity) * flashIntensity * delta;
        particles.material.opacity = Math.min(particles.material.opacity, 1);

        // --- Stjerneskud ---
        shootingStarTimer += delta;
        if (shootingStarTimer >= 5) { // Hver 5. sekund
          createShootingStars(intensity);
          shootingStarTimer = 0;
        }

        // Opdater stjerneskud
        for (let i = shootingStars.length - 1; i >= 0; i--) {
          const star = shootingStars[i];
          star.position.addScaledVector(star.userData.velocity, delta * speedFactor);

          // Opdater opacitet baseret på position
          star.material.opacity -= delta * 0.2;
          if (star.material.opacity <= 0 || star.position.z < -5) {
            // Fjern stjernen fra scenen og arrayet
            scene.remove(star);
            shootingStars.splice(i, 1);
          }
        }

        // --- Opdater fyrværkerier ---
        for (let i = fireworks.length - 1; i >= 0; i--) {
          const firework = fireworks[i];
          firework.life -= delta;
          if (firework.life <= 0) {
            scene.remove(firework.particles);
            fireworks.splice(i, 1);
            continue;
          }

          const positions = firework.particles.geometry.attributes.position.array;
          for (let j = 0; j < positions.length; j += 3) {
            positions[j] += firework.velocities[j / 3].x * delta;
            positions[j + 1] += firework.velocities[j / 3].y * delta;
            positions[j + 2] += firework.velocities[j / 3].z * delta;
          }
          firework.particles.geometry.attributes.position.needsUpdate = true;
        }

        // --- Lavalampe-effekt ---
        if (lavaLamps.length < 5 && Math.random() < 0.01) {
          createLavaLamp();
        }
        lavaLamps.forEach((lamp, index) => {
          lamp.rotation.y += delta * 0.5;
          lamp.material.color.offsetHSL(0.001, 0, 0);
          lamp.scale.setScalar(1 + Math.sin(elapsedTime * 2 + index) * 0.3);
        });

        // Fjern lavalampor efter en vis tid
        if (lavaLamps.length > 5) {
          const lamp = lavaLamps.shift();
          scene.remove(lamp);
        }

        // --- Aurora Borealis ---
        auroraTimer += delta;
        if (auroraTimer >= 60 && !auroraVisible) {
          createAurora();
          auroraVisible = true;
          auroraTimer = 0;
        }
        if (auroraVisible) {
          aurora.material.uniforms.time.value = elapsedTime;
          aurora.material.uniforms.intensity.value = intensity;
          if (auroraTimer >= 50) {
            scene.remove(aurora);
            auroraVisible = false;
            auroraTimer = 0;
          }
        }

        // Ingen baggrundsfarve - behold AR passthrough
      }

      renderer.render(scene, camera);
    }

    // Funktion til at skabe eksploderende partikler
    function createExplodingParticles() {
      const particleCount = 200;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = [];
      const colors = new Float32Array(particleCount * 3);
      const color = new THREE.Color(Math.random(), Math.random(), Math.random());

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;

        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 4
        );
        velocities.push(velocity);

        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 1,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      const particles = new THREE.Points(geometry, material);

      // Placering af eksploderende partikler
      particles.position.set(
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2,
        -2 - Math.random() * 2
      );

      scene.add(particles);

      // Animer partiklerne og fjern dem efter en tid
      const explodeTime = 1; // sekunder
      let elapsed = 0;

      function animate() {
        elapsed += clock.getDelta();
        if (elapsed >= explodeTime) {
          scene.remove(particles);
          return;
        }
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i] += velocities[i / 3].x * delta;
          positions[i + 1] += velocities[i / 3].y * delta;
          positions[i + 2] += velocities[i / 3].z * delta;
        }
        particles.geometry.attributes.position.needsUpdate = true;
        requestAnimationFrame(animate);
      }
      animate();
    }
  </script>
</body>
</html>
