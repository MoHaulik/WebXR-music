<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebXR Musik Visualisering</title>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 1;
    }
    #start-button {
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <button id="start-button">Start AR</button>
  </div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let circles = [];
    let particles;
    let grid;
    let analyser;
    let dataArray;
    let clock = new THREE.Clock();
    let flashIntensity = 0;

    init();

    function init() {
      // Scene og kamera
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0); // Sæt baggrunden til transparent
      document.body.appendChild(renderer.domElement);

      // Lys
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      // Event listener for "Start AR"-knappen
      document.getElementById('start-button').addEventListener('click', () => {
        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            if (supported) {
              const sessionInit = { optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body } };
              navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
            } else {
              alert('WebXR AR-session understøttes ikke på denne enhed.');
            }
          });
        } else {
          alert('WebXR ikke understøttet i denne browser.');
        }
      });
    }

    function onSessionStarted(session) {
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      document.getElementById('start-button').style.display = 'none';

      // Start animationssløjfen efter XR-sessionen er startet
      renderer.setAnimationLoop(render);

      // Opsæt lydanalyse
      navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then((stream) => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        source.connect(analyser);
      });

      // Opret og placer objekter direkte foran brugeren
      createObjects();
    }

    function createObjects() {
      // Placeringsmatrix for objekterne
      const position = new THREE.Vector3(0, 0, -2); // 2 meter foran brugeren
      const quaternion = new THREE.Quaternion();
      const scale = new THREE.Vector3(1, 1, 1);
      const matrix = new THREE.Matrix4();
      matrix.compose(position, quaternion, scale);

      // Opret cirkler
      for (let i = 1; i <= 5; i++) {
        let geometry = new THREE.CircleGeometry(0.1 * i, 64);
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true });
        let circle = new THREE.Mesh(geometry, material);

        // Anvend matrixen for at placere cirklen
        circle.applyMatrix4(matrix);

        scene.add(circle);
        circles.push(circle);
      }

      // Opret partikelsky
      const particleCount = 1000;
      const particlesGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 4;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 4;

        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 1.0;
        colors[i * 3 + 2] = 1.0;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.03,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });
      particles = new THREE.Points(particlesGeometry, particlesMaterial);

      // Anvend matrixen for at placere partikelskyen
      particles.applyMatrix4(matrix);

      scene.add(particles);

      // Opret gitter
      const gridGeometry = new THREE.PlaneGeometry(6, 6, 20, 20);
      const gridMaterial = new THREE.MeshBasicMaterial({
        wireframe: true,
        transparent: true,
        opacity: 0.5,
        vertexColors: true,
        side: THREE.DoubleSide,
      });

      const gridColors = new Float32Array(gridGeometry.attributes.position.count * 3);
      for (let i = 0; i < gridColors.length; i += 3) {
        gridColors[i] = 0.5;     // Initial R værdi
        gridColors[i + 1] = 0.5; // Initial G værdi
        gridColors[i + 2] = 0.5; // Initial B værdi
      }
      gridGeometry.setAttribute('color', new THREE.BufferAttribute(gridColors, 3));

      grid = new THREE.Mesh(gridGeometry, gridMaterial);
      grid.position.set(0, 0, -3); // 3 meter foran brugeren
      scene.add(grid);
    }

    function render() {
      const delta = clock.getDelta();

      if (analyser) {
        analyser.getByteFrequencyData(dataArray);
        const avgFrequency = dataArray.reduce((a, b) => a + b) / dataArray.length;
        const intensity = avgFrequency / 255;

        // --- Slow-motion effekt ---
        const speedFactor = 0.5 + intensity;

        // Opdater cirkler
        circles.forEach((circle, index) => {
          const scale = 1 + dataArray[index % dataArray.length] / 64; // Øg skaleringen
          circle.scale.set(scale, scale, scale);
          circle.material.opacity = dataArray[index % dataArray.length] / 255;
          circle.material.color.setHSL(dataArray[index % dataArray.length] / 255, 1, 0.7); // Øg farvemætning
        });

        // Opdater partikler
        particles.rotation.y += 0.1 * delta * speedFactor;
        const colors = particles.geometry.attributes.color.array;
        for (let i = 0; i < colors.length / 3; i++) {
          const pulse = 0.5 + 0.5 * Math.sin(clock.elapsedTime * 5 + i);
          colors[i * 3] = intensity * pulse; // Gør farver mere intense
          colors[i * 3 + 1] = (1 - intensity) * pulse;
          colors[i * 3 + 2] = 0.5 * pulse;
        }
        particles.geometry.attributes.color.needsUpdate = true;

        // Opdater gitterets bevægelse
        const positions = grid.geometry.attributes.position.array;
        const time = clock.elapsedTime;
        const waveAmplitude = 0.5 + intensity; // Amplitude øges med intensiteten
        const waveSpeed = 1 + intensity;       // Bølger ruller hurtigere med intensitet

        for (let i = 0; i < positions.length; i += 3) {
          const x = positions[i];
          const y = positions[i + 1];
          const frequency = dataArray[Math.floor((i / 3) % dataArray.length)];
          positions[i + 2] = waveAmplitude * Math.sin(x * 2 + time * waveSpeed) * (frequency / 128) +
                             waveAmplitude * Math.sin(y * 2 + time * waveSpeed) * (frequency / 128);
        }
        grid.geometry.attributes.position.needsUpdate = true;

        // Opdater gitterets farver
        const gridColors = grid.geometry.attributes.color.array;
        for (let i = 0; i < gridColors.length / 3; i++) {
          const frequency = dataArray[i % dataArray.length];
          gridColors[i * 3] = frequency / 255;             // Rød komponent
          gridColors[i * 3 + 1] = (255 - frequency) / 255; // Grøn komponent
          gridColors[i * 3 + 2] = 0.5;                     // Blå komponent
        }
        grid.geometry.attributes.color.needsUpdate = true;

        // --- Flash-effekt ved kraftige trommeslag ---
        if (avgFrequency > 200) {
          flashIntensity = 1;
          circles.forEach(circle => circle.material.color.setHSL(0.1, 1, 1)); // Lysere farver på cirkler
          particles.material.opacity = 1; // Gør partikler helt synlige
        }
        flashIntensity *= 0.9; // Fade effekten

        // Forstærk lysstyrken på cirkler og partikler
        circles.forEach(circle => {
          circle.material.opacity = Math.max(circle.material.opacity, 0.5); // Undgå nul opacitet
          circle.material.opacity += (1 - circle.material.opacity) * flashIntensity * delta;
        });
        particles.material.opacity = Math.max(particles.material.opacity, 0.5);
        particles.material.opacity += (1 - particles.material.opacity) * flashIntensity * delta;

        // Sikre, at opaciteten ikke falder til nul
        circles.forEach(circle => {
          circle.material.opacity = Math.min(circle.material.opacity, 1);
        });
        particles.material.opacity = Math.min(particles.material.opacity, 1);

        // Ingen baggrundsfarve - behold AR passthrough
        // Rendererens clear color er allerede sat til transparent i init()
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
